connections {
  snowflake {
    url = ${SNOWFLAKE_URL}
    properties {
      user = datasource_tool_user
      private_key_file = ${SNOWFLAKE_PRIVATE_KEY_FILE}
    }
  }
}

ds {
  datasources {
    snowflake {
      connection = ${connections.snowflake}
      profile {
  relation {
    metrics = [
      {
        name = "row_count"
        description = "Row Count"
        expression = "COUNT(*)"
        enabled = true
      }
      {
        name = "hash_agg"
        description = "Hash of aggregation of all row values"
        expression = "HASH_AGG(*)"
        enabled = true
        includeSources = [snowflake]
      }
    ]
  }

  column {
    metrics = [
      {
        name = "distinct_count"
        description = "The count of distinct values"
        expression = "COUNT(DISTINCT {{ column_name }})"
        includeTypes = [numeric, text, time]
        enabled = true
      }
      {
        name = "null_count"
        description = "The count of null values"
        expression = "SUM(CASE WHEN {{ column_name }} IS NULL THEN 1 ELSE 0 END)"
        includeTypes = [numeric, text, time]
        enabled = true
      }
      {
        name = "empty_count"
        description = "The count of zero values"
        expression = "SUM(CASE WHEN LENGTH({{ column_name }}) = 0 THEN 1 ELSE 0 END)"
        includeTypes = [text]
        enabled = true
        excludeSources = [sqlserver]
      }
      {
        name = "empty_count"
        description = "The count of zero values"
        expression = "SUM(CASE WHEN LEN({{ column_name }}) = 0 THEN 1 ELSE 0 END)"
        includeTypes = [text]
        enabled = true
        includeSources = [sqlserver]
      }
      {
        name = "zero_count"
        description = "The count of zero values"
        expression = "SUM(CASE WHEN {{ column_name }} = 0 THEN 1 ELSE 0 END)"
        includeTypes = [numeric]
        enabled = true
      }
      {
        name = "negative_count"
        description = "The count of negative values"
        expression = "SUM(CASE WHEN {{ column_name }} < 0 THEN 1 ELSE 0 END)"
        includeTypes = [numeric]
        enabled = true
      }
      {
        name = "false_count"
        description = "The count of False Values"
        expression = "SUM(CASE WHEN {{ column_name }} = FALSE THEN 1 ELSE 0 END)"
        includeTypes = [logical]
        enabled = true
        excludeSources = [sqlserver]
      }
      {
        name = "false_count"
        description = "The count of False Values"
        expression = "SUM(CASE WHEN {{ column_name }} = 0 THEN 1 ELSE 0 END)"
        includeTypes = [logical]
        enabled = true
        includeSources = [sqlserver]
      }
      # Quantile statistics: minimum value, Q1, median, Q3, maximum, range, interquartile range
      {
        name = "min"
        description = "Minimum value"
        expression = "MIN({{ column_name }})"
        includeTypes = [numeric, text, time]
        excludeTypes = [datetimeoffset]
        enabled = true
      }
      {
        name = "min"
        description = "Minimum value"
        expression = "FORMAT(MIN({{ column_name }}), 'o')"
        includeTypes = [datetimeoffset]
        enabled = true
      }
      {
        name = "mean"
        description = "Mean value"
        expression = "AVG({{ column_name }})"
        includeTypes = [numeric]
        enabled = false
        excludeSources = [sqlserver]
      }
      {
        name = "max"
        description = "Maximum value"
        expression = "MAX({{ column_name }})"
        includeTypes = [numeric, text, time]
        excludeTypes = [datetimeoffset]
        enabled = true
      }
      {
        name = "max"
        description = "Maximum value"
        expression = "FORMAT(MAX({{ column_name }}), 'o')"
        includeTypes = [datetimeoffset]
        enabled = true
      }
      {
        name = "min_length"
        description = "Minimum length"
        expression = "MIN(LENGTH({{ column_name }}))"
        includeTypes = [text]
        enabled = true
        excludeSources = [sqlserver]
      }
      {
        name = "min_length"
        description = "Minimum length"
        expression = "MIN(LEN({{ column_name }}))"
        includeTypes = [text]
        enabled = true
        includeSources = [sqlserver]
      }
      {
        name = "mean_length"
        description = "Mean length"
        expression = "AVG(LENGTH({{ column_name }}))"
        includeTypes = [text]
        enabled = false
        excludeSources = [sqlserver]
      }
      {
        name = "mean_length"
        description = "Mean length"
        expression = "AVG(LEN({{ column_name }}))"
        includeTypes = [text]
        enabled = false
        includeSources = [sqlserver]
      }
      {
        name = "max_length"
        description = "Maximum length"
        expression = "MAX(LENGTH({{ column_name }}))"
        includeTypes = [text]
        enabled = true
        excludeSources = [sqlserver]
      }
      {
        name = "max_length"
        description = "Maximum length"
        expression = "MAX(LEN({{ column_name }}))"
        includeTypes = [text]
        enabled = true
        includeSources = [sqlserver]
      }
      {
        name = "sum_length"
        description = "Total sum of the lengths"
        expression = "SUM(LENGTH({{ column_name }}))"
        includeTypes = [text]
        enabled = false
        excludeSources = [sqlserver]
      }
      {
        name = "sum_length"
        description = "Total sum of the lengths"
        expression = "SUM(LEN({{ column_name }}))"
        includeTypes = [text]
        enabled = false
        includeSources = [sqlserver]
      }
      {
        name = "stddev"
        description = "The sample standard deviation (square root of sample variance) of non-NULL values."
        expression = "STDDEV({{ column_name }})"
        enabled = true
        includeSources = [snowflake]
        includeTypes = [numeric]
      }
      {
        name = "distribution"
        description = "Distribution of the column"
        expression = """WITH bounds as (
                         SELECT
                           max({{ column_name }}) as max_value,
                           min({{ column_name }}) as min_value,
                           -- The offset is used to normalize the low values
                           -- to 0 so we can safely calculate buckets even
                           -- for negative ranges. The value_range is the
                           -- normalized value for the upper values.
                           0 - min_value as offset,
                           max_value - min_value as value_range
                         FROM {{ table_name }} {{ condition }}
                      ),
                      filtered as (
                        SELECT * FROM {{ table_name }} {{ condition }}
                      ),
                      bucket_rows as (
                          SELECT
                            CASE
                               WHEN value_range <> 0 THEN (t.{{ column_name }} + offset) / value_range
                               ELSE 1
                            END as percent,
                            -- Max is slightly greater than 1 to include the max_value
                            -- in the last bucket.
                            width_bucket(percent, 0, 1.01, 4) as bucket,
                            value_range / 4 as bucket_size,
                            (bucket_size * (bucket - 1)) - offset  as lower_bound,
                            (bucket_size * bucket) - offset as upper_bound
                          FROM filtered t
                          CROSS JOIN bounds b
                      )
                      SELECT
                        count(*) as count
                      FROM bucket_rows b
                      GROUP BY bucket, upper_bound, lower_bound
                      ORDER BY bucket;"""
        type = HISTOGRAM
        enabled = false
        includeTypes = [numeric]
        excludeSources = [sqlite]
      }
      {
        // This distribution is broken but it returns something, so leaving it in for visuals
        name = "distribution (sqlite)"
        description = "Distribution of the column"
        expression = """WITH buckets AS (SELECT
                      (NTILE ( 5 ) OVER (
                        ORDER BY {{ column_name }} )) bucket
                     FROM
                      {{ table_name }})
                     SELECT COUNT(*) AS count FROM buckets GROUP BY bucket;"""
        type = HISTOGRAM
        enabled = true
        includeSources = [sqlite]
      }
    ]
  }
}
    }
  }
}
